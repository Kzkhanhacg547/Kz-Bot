module.exports.config = {
  name: "altp",
  version: "1.0.0", 
  hasPermssion: 0,
  credits: "DungUwU",
  description: "Ch∆∞∆°ng tr√¨nh Ai l√† tri·ªáu ph√∫ b·∫£n simple",
  commandCategory: "Tr√≤ ch∆°i", 
  usages: "< play/help/bxh >", 
  cooldowns: 3,
  dependencies: {
    "axios": ""
  }
};

const questionsURL = global.thanhdz ? global.thanhdz.altp_url : "";

function shuffle(array) {
  let currentIndex = array.length,  randomIndex;
  while (currentIndex != 0) {
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;

[array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
  }

  return array;
}

function formatQuestion(question) {
  const answersString = [
    "A. " + question.answers['a'],
    "B. " + question.answers['b'],
    "C. " + question.answers['c'],
    "D. " + question.answers['d']
  ].join("\n");
  return question.question + "\n" + answersString;
}

const _play_fee = 4000;
const _question_rewards = [
  0,0,0,0,2000,
  2100,2150,2300,2500,5000,
  6000,7500,9000,12000,20000
];

const _timelimit_per_question = 60000;

function calReward(userData, lost) {
  const index = userData.index || 0;
  let reward = null;

  if (lost == true) {
    if (index < 5) reward = 0;
    else if (index < 10) reward = _question_rewards[4];
    else reward = _question_rewards[9];
  } else {
    reward = _question_rewards[index];
  }

  return reward || 0;
}

async function _finishing_game(send, senderID, threadID, Currencies, Users, lost) {
  const userData = {...global._isPlaying_altp.get(senderID)};
  if (!userData.hasOwnProperty("index")) return;
  global._isPlaying_altp.delete(senderID);

  const correctAnswers = lost == true ? userData.index : userData.index + 1;
  const reward = calReward(userData, lost);
  const _help_count = [
    userData.help_1,
    userData.help_2,
    userData.help_3
  ].reduce((tol, cur) => tol + (cur == true ? 1 : 0), 0);

  const userName = (await Users.getNameUser(senderID)) || senderID;
  const msg = `Ng∆∞·ªùi ch∆°i ${userName} th√¢n m·∫øn, tr√≤ ch∆°i ƒë√£ k·∫øt th√∫c` +
        `\n‚Ä¢ B·∫°n tr·∫£ l·ªùi ƒë√∫ng: ${correctAnswers}/15` +
        `\n‚Ä¢ L∆∞·ª£t tr·ª£ gi√∫p ƒë√£ d√πng: ${_help_count}/3` +
        `\n‚Ä¢ Ph·∫ßn th∆∞·ªüng b·∫°n nh·∫≠n ƒë∆∞·ª£c: +${reward}$`;
  send(msg, threadID, async (err) => {
    try {
      if (err) throw err;
      await Currencies.increaseMoney(senderID, parseInt(reward));
      const _USER_DATA = (await Users.getData(senderID)).data || {};

      if (!_USER_DATA.hasOwnProperty("altp")) _USER_DATA.altp = { correct: 0, moneyGain: 0 };
      _USER_DATA.altp.correct += correctAnswers;
      _USER_DATA.altp.moneyGain += reward;

      await Users.setData(senderID, { data: _USER_DATA });
    } catch(e) {
      console.error(e);
      send("ƒê√£ c√≥ l·ªói x·∫£y ra...", threadID);
    }const endpoint = 'https://API.diennguuvc.repl.co'
    const axios = require('axios')
    const APIKEY =  "DismeVIP_9100360227"
    module.exports.config = {
      name: "altp",
      version: "1.0.0",
      hasPermssion: 0,
      credits: "D-Jukie",
      description: "Game tr·∫£ l·ªùi c√¢u h·ªèi 'Ai l√† tri·ªáu ph√∫' - D-Jukie",
      commandCategory: "Game",
      usages: "[]",
      cooldowns: 0
    }

    module.exports.languages = {
      "vi": {
          "APIKEY": '[ ùóîùóüùóßùó£ ] - API KEY kh√¥ng ch√≠nh x√°c ho·∫∑c ƒë√£ h·∫øt h·∫°n d√πng th·ª≠',
          "registerFail": '[ ùóîùóüùóßùó£ ] - üë§ Ng∆∞·ªùi ch∆°i ƒë√£ c√≥ t√†i kho·∫£n tr√™n m√°y ch·ªß',
          "registerSuccess": '[ ùóîùóüùóßùó£ ] - ƒêƒÉng k√Ω t√†i kho·∫£n tr√™n m√°y ch·ªß "Ai l√† tri·ªáu ph√∫" th√†nh c√¥ng üë§',
          "notFoundInfo": '[ ùóîùóüùóßùó£ ] - üö´ Kh√¥ng t√¨m th·∫•y th√¥ng tin c·ªßa ban, vui l√≤ng ƒëƒÉng k√Ω!\n‚è© L·ªánh: "%1 -r"',
          "showInfo": '[ ===== ùêåùê¢ùê´ùêöùê¢ ùêèùê´ùê®ùê£ùêûùêúùê≠ ===== ]\n\nüë§ ùóßùó≤ÃÇùóª: %1\n‚ö°Ô∏è ùó¶ùóºÃÇÃÅ ùóΩùóºùó∂ùóªùòÅùòÄ ùóµùó∂ùó≤Ã£ÃÇùóª ùó∞ùóºÃÅ: %2\n‚ö°Ô∏è ùóñùóÆÃÇùòÇ ùóµùóºÃâùó∂ ùó∞ùóÆùóº ùóªùóµùóÆÃÇÃÅùòÅ ùòÅùòÇÃõÃÄùóªùó¥ ùòÅùóøùóÆÃâ ùóπùóºÃõÃÄùó∂: %3',
          "ranking": 'üèÜ ùêÅùêöÃâùêßùê† ùêóùêûÃÇÃÅùê© ùêáùêöÃ£ùêßùê† ùêíùêûùê´ùêØùêûùê´ üèÜ\n\n',
          "errorPlay": '[ ùóîùóüùóßùó£ ] - üö´ M·ªói nh√≥m ch·ªâ ƒë∆∞·ª£c ph√©p c√≥ m·ªôt ng∆∞·ªùi ch∆°i c√πng l√∫c!!',
          "typeQuestion": '[ ùóîùóüùóßùó£ ] - üìù B·∫°n vui l√≤ng ch·ªçn d·∫°ng c√¢u h·ªèi mu·ªën hi·ªÉn th·ªã:\n1. VƒÉn b·∫£n\n2. H√¨nh ·∫£nh\n‚è© Th·ª±c hi·ªán reply tin nh·∫Øn n√†y [Number]',
          "default": `[ ùêÅùêéùêì ] ‚Ä¢ ùêìùê´ùê®ÃÄ ùêÇùê°ùê®Ãõùê¢ ùêÄùê¢ ùêãùêöÃÄ ùêìùê´ùê¢ùêûÃ£ÃÇùêÆ ùêèùê°ùêÆÃÅ üéÆ\n\n‚Ä¢ ƒêƒÉng k√Ω: ${global.config.PREFIX}${this.config.name} register\n‚Ä¢ X·∫øp h·∫°ng: ${global.config.PREFIX}${this.config.name} rank\n‚Ä¢ Th√¥ng tin ng∆∞·ªùi ch∆°i: ${global.config.PREFIX}${this.config.name} info\n‚Ä¢ B·∫Øt ƒë·∫ßu ch∆°i:  ${global.config.PREFIX}${this.config.name} play\n\nH√£y l√† ng∆∞·ªùi ƒë·∫ßu ti√™n tr·∫£ l·ªùi h·∫øt 15 c√¢u h·ªèi c·ªßa ch∆∞∆°ng tr√¨nh üí∏`,
          "stop": `‚Ä¢ B·∫°n ƒë√£ quy·∫øt ƒë·ªãnh d·ª´ng cu·ªôc ch∆°i t·∫°i m·ªëc c√¢u h·ªèi th·ª© %1!\n‚Ä¢ S·ªë ti·ªÅn b·∫°n nh·∫≠n ƒë∆∞·ª£c t·ª´ ch∆∞∆°ng tr√¨nh l√†: %2 vnd`,
          "help": 'üìñ L∆∞u √Ω: \n‚Ä¢ H√£y nh·∫Øn \n"stop" ƒë·ªÉ ng·ª´ng cu·ªôc ch∆°i\n"help 1" ƒë·ªÉ lo·∫°i b·ªè 2 ƒë√°p √°n sai.(1)\n"help 2" ƒë·ªÉ t·∫°o vote trong group.(unlimited)\n"help 3" ƒë·ªÉ ƒë·ªïi c√¢u h·ªèi(1)',
          "true": 'ü•≥ Xin ch√∫c m·ª´ng, b·∫°n ƒë√£ tr·∫£ l·ªùi ƒë√∫ng!',
          "true15": 'ü•≥Xin ch√∫c m·ª´ng, b·∫°n l√† ng∆∞·ªùi ƒë·∫ßu ti√™n tr·∫£ l·ªùi ƒë√∫ng 15 c√¢u h·ªèi c·ªßa ch∆∞∆°ng tr√¨nh.\n‚Ä¢ S·ªë ti·ªÅn b·∫°n nh·∫≠n ƒë∆∞·ª£c t·ª´ ch∆∞∆°ng tr√¨nh l√†: %1 vnd',
          "timeout": `‚Ä¢ H·∫øt th·ªùi gian, b·∫°n ƒë√£ kh√¥ng ƒë∆∞a ra ƒë∆∞·ª£c ph∆∞∆°ng √°n ch√≠nh x√°c c·ªßa ch∆∞∆°ng tr√¨nh.\n‚Ä¢ B·∫°n d·ª´ng cu·ªôc ch∆°i t·∫°i c√¢u h·ªèi th·ª© %1!\n‚Ä¢ S·ªë ti·ªÅn b·∫°n nh·∫≠n ƒë∆∞·ª£c t·ª´ ch∆∞∆°ng tr√¨nh l√†: %2 vnd`,
          "false": `‚Ä¢ Th·∫≠t ƒë√°ng ti·∫øc, ƒë√≥ kh√¥ng ph·∫£i ph∆∞∆°ng √°n ch√≠nh x√°c c·ªßa ch∆∞∆°ng tr√¨nh.\n‚Ä¢ B·∫°n d·ª´ng cu·ªôc ch∆°i t·∫°i c√¢u h·ªèi th·ª© %1!\n‚Ä¢ S·ªë ti·ªÅn b·∫°n nh·∫≠n ƒë∆∞·ª£c t·ª´ ch∆∞∆°ng tr√¨nh l√†: %2 vnd`,
          "notFoundQuestion": "‚ùé C√¢u h·ªèi n√†y kh√¥ng t·ªìn t·∫°i!!"
      },
      "en": {}
    }

    module.exports.onLoad = function() {
        global.timer = new Object()
        global.quiz = new Object()
    }

    const download = async (url) => {
      const response = await axios.get(url, {
          responseType: 'stream'
      })
      return response.data
    }

    const reply = (type, info, event, option) => {
      try {
          var obj = { type: type, name: this.config.name, messageID: info.messageID, author: event.senderID }
          if (option) { obj[option.key] = option.value }
          global.quiz[event.threadID].messageID = info.messageID
      }
      catch(e) {}
      return obj
    }

    const correct = (id) => {
        clearTimeout(global.timer[id])
        delete global.timer[id]
    }
    const start = (id, time, api, getText, idPlayer) => {
        global.timer[id] = setTimeout(function () {
            if (!global.quiz[id]) return
            axios.get(`${endpoint}/game/quiz?type=stop&id=${idPlayer}&apikey=${APIKEY}`)
            api.sendMessage(getText("timeout", global.quiz[id].numberQuiz, global.quiz[id].coins), id)
            delete global.quiz[id]
            return
        }, time * 1000)
    }

    const help = (id, time, api, getText, idPlayer) => {
        correct(id)
        start(id, time, api, getText, idPlayer)
    }

    async function getQuestion(type, level, id, threadID, api, getText, help) {
      type = String(type)
      level = String(level)
      try {
          if (help == 3) {
              var resp = (await axios.get(`${endpoint}/game/quiz?type=change&id=${id}&typeq=${(global.quiz[threadID].typeQuiz == 1) ? 'text' : 'image'}&apikey=${APIKEY}`)).data
          }
          if (help == 1) {
              var resp = (await axios.get(`${endpoint}/game/quiz?type=5050&typeq=${(global.quiz[threadID].typeQuiz == 1) ? 'text' : 'image'}&id=${global.quiz[threadID].idPlayer}&apikey=${APIKEY}`)).data
              resp.time = 30
          }
          if (!help) {
              var resp = (await axios.get(`${endpoint}/game/quiz?type=altp&level=${level}&id=${id}&typeq=${(global.quiz[threadID].typeQuiz == 1) ? 'text' : 'image'}&apikey=${APIKEY}`)).data
          }
      } catch (e) {
          if(global.tryGet == 1) return
          global.tryGet = 1
          await getQuestion(type, level, id, threadID, api, getText, help)
      }
      switch (type) {
      case '1': {
          if (resp.status == false) { return 3 }
          var ans = resp.dataGame.dapan.map(i => {
              if (i == null) { i = "" }
              return i
          })
          var msg = `‚ùì C√¢u h·ªèi th·ª© ${resp.dataGame.level} (${resp.time ? resp.time : 60}s) - ${resp.dataGame.coins} vnd\n${resp.dataGame.question}\nA: ${ans[0]}\nB: ${ans[1]}\nC: ${ans[2]}\nD: ${ans[3]}`
          global.quiz[threadID].help_2 = resp.dataGame
          start(threadID, 60, api, getText, id)
          return { msg, time: resp.dataGame.time, coins: resp.dataGame.coins }
      }
      case '2': {
          if (resp.status == false) { return 3 }
          var msg = { body: `‚ùì C√¢u h·ªèi th·ª© ${resp.dataGame.level} (${resp.time ? resp.time : 60}s) - ${resp.dataGame.coins} vnd`, attachment: await download(resp.dataGame.url) }
          global.quiz[threadID].help_2 = resp.dataGame
          start(threadID, 65, api, getText, id)
          return { msg, time: resp.dataGame.time, coins: resp.dataGame.coins }
      }
      default: return
      }
    }

    module.exports.handleEvent = async ({ event, api, Users, Currencies, getText }) => {
      const { threadID, messageID, senderID, body } = event
      if (!global.quiz || !global.quiz[threadID] || global.quiz[threadID].idPlayer != senderID) return
      switch (body) {
      case 'stop': {
          api.unsendMessage(global.quiz[threadID].messageID)
          await Currencies.increaseMoney(senderID, parseInt(global.quiz[threadID].coins))
          var resp = (await axios.get(`${endpoint}/game/quiz?type=stop&id=${senderID}&apikey=${APIKEY}`)).data
          api.sendMessage(getText("stop", global.quiz[threadID].numberQuiz, global.quiz[threadID].coins), threadID, messageID)
          delete global.quiz[threadID]
          return
      }
      case 'help 1': {
          var question = await getQuestion(global.quiz[threadID].typeQuiz, global.quiz[threadID].numberQuiz, senderID, threadID, api, getText, 1)
          if (question == 3) return api.sendMessage('‚Ä¢ B·∫°n ƒë√£ h·∫øt l∆∞·ª£t lo·∫°i b·ªè 2 ƒë√°p √°n sai!', threadID)
          api.unsendMessage(global.quiz[threadID].messageID)
          help(threadID, 30000, api, getText, senderID)
          api.sendMessage(question.msg, threadID, (error, info) => global.client.handleReply.push(reply('ans', info, event, { key: 'time', value: question.time }, event)))
          break
      }
      case 'help 2': {
          var dataGame = global.quiz[threadID].help_2
          api.createPoll(dataGame.question, threadID, {
              [dataGame.dapan[0]]: false,
              [dataGame.dapan[1]]: false,
              [dataGame.dapan[2]]: false,
              [dataGame.dapan[3]]: false
          }, (err) => { if (err) return console.log(err)
          })
          break
      }
      case 'help 3': {
          var question = await getQuestion(global.quiz[threadID].typeQuiz, global.quiz[threadID].numberQuiz, senderID, threadID, api,getText, 3)
          if (question == 3) return api.sendMessage('‚Ä¢ B·∫°n ƒë√£ h·∫øt l∆∞·ª£t ƒë·ªïi c√¢u h·ªèi!', threadID)
          api.unsendMessage(global.quiz[threadID].messageID)
          help(threadID, 60000, api, getText, senderID)
          api.sendMessage(question.msg, threadID, (error, info) => global.client.handleReply.push(reply('ans', info, event, { key: 'time', value: question.time }, event)))
          break
      }
      default: return
      }
    }
    module.exports.handleReply = async function ({ api, event, handleReply, Currencies, getText }) {
      const { threadID, messageID, senderID, body } = event
      if (handleReply.author != senderID) return
      switch (handleReply.type) {
      case 'choose': {
          global.quiz[threadID] = {}
          global.quiz[threadID].numberQuiz = 1
          global.quiz[threadID].idPlayer = senderID
          global.quiz[threadID].coins = 0
          if (body == 1) {
              api.sendMessage(getText("help"), threadID, messageID)
              await new Promise(resolve => setTimeout(resolve, 200))
              global.quiz[threadID].typeQuiz = 1
          } else if (body == 2) {
              api.sendMessage(getText("help"), threadID, messageID)
              await new Promise(resolve => setTimeout(resolve, 200))
              global.quiz[threadID].typeQuiz = 2
          } else return
      }
      case 'start': {
          api.unsendMessage(handleReply.messageID)
          var question = await getQuestion(global.quiz[threadID].typeQuiz, global.quiz[threadID].numberQuiz, senderID, threadID, api, getText)
          return api.sendMessage(question.msg, threadID, (error, info) => global.client.handleReply.push(reply('ans', info, event, { key: 'time', value: question.time }, event)))
      }
      case 'ans': {
        if(!global.quiz[threadID]) return
          var list = [' ', 'a', 'b', 'c', 'd']
          var check = await checkAns(body.toLowerCase(), senderID, handleReply.time)
          if (list.includes(body.toLowerCase()) && check == true) {
              correct(threadID)
              api.unsendMessage(handleReply.messageID)
              global.quiz[threadID][global.quiz[threadID].numberQuiz] = true
              global.quiz[threadID].numberQuiz = global.quiz[threadID].numberQuiz + 1
              api.sendMessage(getText('true'), threadID, messageID)
              await new Promise(resolve => setTimeout(resolve, 200))
              if (global.quiz[threadID].numberQuiz > 15) {
                  await Currencies.increaseMoney(senderID, parseInt(global.quiz[threadID].coins))
                  api.sendMessage(getText('true15', global.quiz[threadID].coins), threadID)
                  delete global.quiz[threadID]
                  return
              }
              var question = await getQuestion(global.quiz[threadID].typeQuiz, global.quiz[threadID].numberQuiz, senderID, threadID, api, getText)
              global.quiz[threadID].coins = question.coins
              return api.sendMessage(question.msg, threadID, (error, info) => global.client.handleReply.push(reply('ans', info, event, { key: 'time', value: question.time })))
          }
          if (list.includes(body.toLowerCase()) && check == false) {
              correct(threadID)
              api.unsendMessage(handleReply.messageID)
              await Currencies.increaseMoney(senderID, parseInt(global.quiz[threadID].coins))
              api.sendMessage(getText("false", global.quiz[threadID].numberQuiz, global.quiz[threadID].coins), threadID, messageID)
              delete global.quiz[threadID]
              return
          }
          if (list.includes(body.toLowerCase()) && check == 404 || check == 503) {
              return api.sendMessage(getText("notFoundQuestion"), threadID, messageID)
          }
      }
      default: return
      }
      async function checkAns(ans, id, time) {
          var resp = (await axios.get(`${endpoint}/game/quiz?type=check&dapan=${ans}&id=${id}&time=${time}&apikey=${APIKEY}`)).data
          return resp.status
      }
    }
    module.exports.run = async function ({ api, event, args, Users, getText }) {
      const { threadID, messageID, senderID } = event
      const type = args[0]
      const name = (await Users.getData(senderID)).name
      const checkKey = (await axios.get(`${endpoint}/game/quiz?type=info&id=${senderID}&apikey=${APIKEY}`)).data
      if(checkKey.error && checkKey.error == 1) {
          return api.sendMessage(getText("APIKEY"), threadID, messageID)
      }
      switch (type) {
      case 'register':
      case '-r': {
          var resp = await axios.get(`${endpoint}/game/quiz?type=register&name=${encodeURI(name)}&id=${senderID}&apikey=${APIKEY}`)
          if (resp.data.error) return api.sendMessage(getText("registerFail"), threadID, messageID)
          return api.sendMessage(getText("registerSuccess"), threadID, messageID)
      }
      case 'info':
      case '-i': {
          var resp = await axios.get(`${endpoint}/game/quiz?type=info&id=${senderID}&apikey=${APIKEY}`)
          if (resp.data.error) return api.sendMessage(getText("notFoundInfo", this.config.name), threadID, messageID)
          return api.sendMessage(getText("showInfo", resp.data.name, resp.data.point, resp.data.highest_Level), threadID, messageID)
      }
      case 'rank':
      case '-t': {
          var resp = (await axios.get(`${endpoint}/game/quiz?type=rank&apikey=${APIKEY}`)).data
          var result = getText("ranking")
          for (let i = 0; i <= 4; i++) {
              if (!resp.data[i]) continue
              result += `‚Ä¢ TOP ${i+1}. ${resp.data[i].name} - ${resp.data[i].point}\n`
          }
          return api.sendMessage({ body: result, attachment: await download(resp.url)}, threadID, messageID)
      }
      case 'play':
      case '-p': {
          if (global.quiz[threadID]) return api.sendMessage(getText("errorPlay"), threadID, messageID)
          var resp = await axios.get(`${endpoint}/game/quiz?type=info&id=${senderID}&apikey=${APIKEY}`)
          if (resp.data.error) return api.sendMessage(getText("notFoundInfo", this.config.name), threadID, messageID)
          return api.sendMessage(getText("typeQuestion"), threadID, (error, info) => global.client.handleReply.push(reply('choose', info, event)), messageID)
      }
      default: return api.sendMessage({ body: getText("default"), attachment: await download("https://i.imgur.com/T1gYRR0.png")}, threadID, messageID)
      }
    }
  });

  return;
}

module.exports.onLoad = ({}) => {
  if (!global.hasOwnProperty('_isPlaying_altp')) global._isPlaying_altp = new Map();
  if (!global.hasOwnProperty('_data_altp')) global._data_altp = new Array();
  global.nodemodule["axios"].get(questionsURL)
    .then(res => {
      for (const question of res.data) {
        global._data_altp.push(question);
      }
      ("ƒê√£ t·∫£i l·ªánh Ai l√† tri·ªáu ph√∫ th√†nh c√¥ng");
    })
    .catch(e => {
      console.error(e);
      global._loadFailed_altp = true;
    });
}

module.exports.run = async ({ api, event, args, Users, Currencies }) => {
  const send = api.sendMessage;
  const { threadID, messageID, senderID } = event;
  const query = args[0].toLowerCase() || null;
  let _isPaid = false;

  if (global._loadFailed_altp == true || global._data_altp.length == 0) {
    send("L·ªánh n√†y hi·ªán kh√¥ng kh·∫£ d·ª•ng, th·ª≠ l·∫°i trong ch√∫t l√°t...", threadID);
  } else {
    try {
      switch(query) {
        case "play":
          {
            if (global._isPlaying_altp.has(senderID)) {
              send("B·∫°n ƒëang ·ªü trong ph·∫ßn ch∆°i c·ªßa m√¨nh, kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu ph·∫ßn ch∆°i kh√°c", threadID);
            } else {
              const userMoney = (await Currencies.getData(senderID)).money || null;
              if (userMoney == null) {
                send("T√†i kho·∫£n c·ªßa b·∫°n kh√¥ng c√≥ trong h·ªá th·ªëng ti·ªÅn t·ªá, vui l√≤ng th·ª≠ l·∫°i sau...", threadID);
              } else {
                if (userMoney < _play_fee) {
                  send(`B·∫°n c·∫ßn ${_play_fee}$ ƒë·ªÉ tham gia...`, threadID);
                } else {
                  await Currencies.decreaseMoney(senderID, _play_fee);
                  _isPaid = true;

                  const questions = shuffle([...global._data_altp]).slice(0, 15);
                  const _new_game_data = {
                    index: 0,
                    help_1: false,
                    help_2: false,
                    help_3: false,
                    questions
                  }

                  send(`C√¢u 1 ( Ph·∫ßn th∆∞·ªüng: ${_question_rewards[0]}$ ):\n` + formatQuestion(questions[0]), threadID, async (err, info) => {
                    if (err) throw err;
                    else {
                      _new_game_data.messageID = info.messageID;
                      global._isPlaying_altp.set(senderID, {..._new_game_data});
                      global.client.handleReply.push({
                        name: this.config.name,
                        messageID: info.messageID,
                        author: senderID
                      });

                      await new Promise(resolve => setTimeout(resolve, _timelimit_per_question));
                      const userData_after = global._isPlaying_altp.get(senderID) || {};

                      if (userData_after.messageID == _new_game_data.messageID) {
                        _finishing_game(send, senderID, threadID, Currencies, Users, true);
                      }
                    }
                  }, messageID);
                }
              }
            }

            break;
          }
        case "help":
          {
            if (!global._isPlaying_altp.has(senderID)) {
              send("B·∫°n ƒëang kh√¥ng c√≥ ph·∫ßn ch∆°i n√†o c·∫£...", threadID);
            } else {
              const userData = global._isPlaying_altp.get(senderID);

              let num = 1;
              const help_1 = userData.help_1 == false ? `\n${num++}. Lo·∫°i b·ªè 2 ƒë√°p √°n sai` : "";
              const help_2 = userData.help_2 == false ? `\n${num++}. L·∫•y b√¨nh ch·ªçn t·ª´ kh√°n gi·∫£` : "";
              const help_3 = userData.help_3 == false ? `\n${num++}. Thay ƒë·ªïi ho√†n to√†n c√¢u h·ªèi` : "";

              if (num == 1) {
                send("B·∫°n kh√¥ng c√≤n l∆∞·ª£t tr·ª£ gi√∫p n√†o c·∫£..", threadID, messageID);
              } else {
                send("====== ùêìùêëùêéÃõÃ£ ùêÜùêàùêîÃÅùêè ======" + help_1 + help_2 + help_3 + "\n‚Ä¢ Ph·∫£n h·ªìi tin nh·∫Øn n√†y v·ªõi s·ªë th·ª© t·ª± tr·ª£ gi√∫p b·∫°n mu·ªën d√πng", threadID, (err, info) => {
                  if (err) console.error(err);
                  else {
                    global.client.handleReply.push({
                      name: this.config.name,
                      messageID: info.messageID,
                      author: senderID,
                      type: "help"
                    })
                  }
                });
              }
            }

            break;
          }
        case "bxh":
          {
            const allUsersDatas = ((await Users.getAll()) || [])
              .filter(e => e.hasOwnProperty("data") && e.data != null)
              .filter(e => e.data.hasOwnProperty("altp"));

            if (allUsersDatas.length == 0) {
              send("Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ th·ªëng k√™...", threadID);
            } else {
              const sortedData = allUsersDatas.sort((a, b) => b.data.altp.correct == a.data.altp.correct ? a.name.localeCompare(b.data.name) : b.data.altp.correct - a.data.altp.correct);
              const selfIndex = sortedData.findIndex(e => e.userID == senderID);

              let msg = "==== ùêÅùêÄÃâùêçùêÜ ùêóùêÑÃÇÃÅùêè ùêáùêÄÃ£ùêçùêÜ ====";

              const loopTo = sortedData.length < 10 ? sortedData.length : 10;
              for (let i = 0; i < loopTo; i++) {
                msg += `\n${i + 1}. ${sortedData[i].name} - ${sortedData[i].data.altp.correct} ƒëi·ªÉm (${sortedData[i].data.altp.moneyGain}$)`;
              }

              msg += "\n";

              if (selfIndex != -1 && selfIndex > 9) msg += "\nB·∫°n ƒë·ª©ng th·ª© " + (selfIndex + 1) + " v·ªõi " + sortedData[selfIndex].data.altp.correct + " ƒëi·ªÉm (" + sortedData[selfIndex].data.altp.moneyGain + "$)";
              send(msg, threadID);
            }

            break;
          }
        default:
          {
            send("=== ùêÄùêà ùêãùêÄÃÄ ùêìùêëùêàùêÑÃ£ÃÇùêî ùêèùêáùêîÃÅ ===\n- altp play: ƒê·ªÉ tham gia ch∆∞∆°ng tr√¨nh\n- altp help: ƒê·ªÉ s·ª≠ d·ª•ng quy·ªÅn tr·ª£ gi√∫p\n- altp bxh: ƒê·ªÉ xem b·∫£ng x·∫øp h·∫°ng ng∆∞·ªùi ch∆°i", threadID);
            break;
          }
      }
    } catch(e) {
      if (query != "bxh") {
        global._isPlaying_altp.delete(senderID);
        if (_isPaid == true) {
          Currencies.increaseMoney(senderID, _play_fee).catch(e => console.error(e));
        }
        send("ƒê√£ c√≥ l·ªói x·∫£y ra, ƒëang ho√†n tr·∫£ ti·ªÅn...", threadID);
      }
      console.error(e);
    }
  }

  return;
}


function checkAnswer(choice, data) {
  return choice == data.correctAnswer;
}

// C·∫ßn th√¨ d√πng...
// function getCorrectAnswerString(data) {
// 	return data.correctAnswer.toUpperCase() + '. ' + data.answers[data.correctAnswer];
// }

function get_2_wrong_answers(data) {
  const { correctAnswer } = data;
  const wrongAnswers = shuffle(["a", "b", "c", "d"].filter(e => e != correctAnswer));
  return wrongAnswers.slice(0, 2);
}

// kh√° l√† bug, fix dc fix ƒëi, l∆∞·ªùi l·∫Øm ~~
function generatePercents() {
  const percents = [];

  let percentLeft = 100;
  for (let i = 0; i < 4; i++) {
    let randPercent = (i == 3 || percentLeft == 0) ? percentLeft : Math.floor(Math.random() * 50);
    while(randPercent > percentLeft) {
      randPercent = Math.floor(Math.random() * 50);
    }

    percentLeft -= randPercent;
    percents.push(randPercent);
  }

  return shuffle(percents);
}

function vote_answers(data) {
  const { correctAnswer } = data;
  const percents = generatePercents();

  if (Math.random() > 0.3) {
    const correctAnswerIndex = ["a", "b", "c", "d"].indexOf(correctAnswer);
    const highestPercentIndex = percents.indexOf(Math.max(...percents));
    const highestPercent = percents[highestPercentIndex];

    const swapToIndex = correctAnswerIndex;
    const swapToValue = percents[swapToIndex];

    percents[swapToIndex] = highestPercent;
    percents[highestPercentIndex] = swapToIndex;
  }

  return percents;
}

module.exports.handleReply = ({ api, event, Currencies, Users, handleReply }) => {
  const send = api.sendMessage;
  const { author } = handleReply;
  const { senderID, threadID, body } = event;
  const choice = body.toLowerCase() || null;

  if (author == senderID && choice != null) {
    const userData = {...global._isPlaying_altp.get(senderID)};
    if (!userData.hasOwnProperty("index")) return;
    global.client.handleReply.splice(global.client.handleReply.findIndex(e => e.messageID == handleReply.messageID));

    const { questions, index } = userData;

    if (handleReply.type == "help") {
      api.unsendMessage(handleReply.messageID);
      const availableProperty = ["help_1", "help_2", "help_3"].filter(e => userData[e] == false);
      const help_available_count = availableProperty.length;
      if (parseInt(choice) > help_available_count || parseInt(choice) < 1) {
        send("L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá...", threadID);
      } else {
        const availableProperty = ["help_1", "help_2", "help_3"].filter(e => userData[e] == false);
        const _help_chosen_property = availableProperty[parseInt(choice) - 1];
        userData[_help_chosen_property] = true;
        global._isPlaying_altp.set(senderID, userData);

        if (_help_chosen_property == "help_1") {
          const wrongAnswers = get_2_wrong_answers(questions[index]);
          send("ƒê√°p √°n sai l√†: " + wrongAnswers.join(", "), threadID);
        } else if (_help_chosen_property == "help_2") {
          const percents = vote_answers(questions[index]);
          send("K·∫øt qu·∫£ b·∫ßu ch·ªçn:\n" + ["a", "b", "c", "d"].map((e, i) => e.toUpperCase() + ". " + percents[i] + "%").join("\n"), threadID);
        } else {
          const newQuestion = shuffle([...global._data_altp])
                      .filter(e => questions.some(ee => ee.question != e.question))[0];

          api.unsendMessage(userData.messageID);
          userData.questions[userData.index] = newQuestion;
          global._isPlaying_altp.set(senderID, userData);

          send(`C√¢u ${userData.index + 1} ( Ph·∫ßn th∆∞·ªüng: ${_question_rewards[userData.index]}$ ):\n` + formatQuestion(questions[userData.index]), threadID, async (err, info) => {
            try {
              if (err) throw err;
              else {
                userData.messageID = info.messageID;
                global._isPlaying_altp.set(senderID, {...userData});
                global.client.handleReply.push({
                  name: this.config.name,
                  messageID: info.messageID,
                  author: senderID
                });

                await new Promise(resolve => setTimeout(resolve, _timelimit_per_question));
                const userData_after = global._isPlaying_altp.get(senderID) || {};

                if (userData_after.messageID == userData.messageID) {
                  _finishing_game(send, senderID, threadID, Currencies, Users, true);
                }
              }
            } catch(e) {
              console.error(e);
            }
          });
        }
      }
    } else {
      const _isCorrect = checkAnswer(choice, questions[index]);

      if (_isCorrect == true) {
        if (userData.index == 14) {
          _finishing_game(send, senderID, threadID, Currencies, Users, false);
        } else {
          send("B·∫°n ƒë√£ tr·∫£ l·ªùi ch√≠nh x√°c c√¢u h·ªèi n√†y, th·∫£ c·∫£m x√∫c üëç ƒë·ªÉ ti·∫øp t·ª•c ho·∫∑c c·∫£m x√∫c kh√°c ƒë·ªÉ d·ª´ng cu·ªôc ch∆°i" +  `\n‚Ä¢ M·ª©c th∆∞·ªüng hi·ªán t·∫°i: ${_question_rewards[userData.index]}$`, threadID, async (err, info) => {
            try {
              if (err) throw err;
              else {
                userData.messageID = info.messageID;
                global._isPlaying_altp.set(senderID, {...userData});
                global.client.handleReaction.push({
                  name: this.config.name,
                  messageID: info.messageID,
                  author: senderID
                });

                await new Promise(resolve => setTimeout(resolve, _timelimit_per_question));
                const userData_after = global._isPlaying_altp.get(senderID) || {};

                if (userData_after.messageID == userData.messageID) {
                  _finishing_game(send, senderID, threadID, Currencies, Users, false);
                }
              }
            } catch(e) {
              console.error(e);
            }
          });
        }
      } else {
        _finishing_game(send, senderID, threadID, Currencies, Users, true);
      }
    }
  }

  return;
}

module.exports.handleReaction = ({ api, event, Currencies, Users, handleReaction }) => {
  const send = api.sendMessage;
  const { author } = handleReaction;
  const { userID, threadID, reaction } = event;

  const userData = {...global._isPlaying_altp.get(userID)};
  if (!userData.hasOwnProperty("index")) return;

  global.client.handleReaction.splice(global.client.handleReaction.findIndex(e => e.messageID == handleReaction.messageID), 1);
  api.unsendMessage(handleReaction.messageID);

  const { questions } = userData;
  if (reaction == 'üëç') {
    userData.index++;
    global._isPlaying_altp.set(userID, userData);

    send(`C√¢u ${userData.index + 1} ( Ph·∫ßn th∆∞·ªüng: ${_question_rewards[userData.index]}$ ):\n` + formatQuestion(questions[userData.index]), threadID, async (err, info) => {
      try {
        if (err) throw err;
        else {
          userData.messageID = info.messageID;
          global._isPlaying_altp.set(userID, {...userData});
          global.client.handleReply.push({
            name: this.config.name,
            messageID: info.messageID,
            author: userID
          });

          await new Promise(resolve => setTimeout(resolve, _timelimit_per_question));
          const userData_after = global._isPlaying_altp.get(userID) || {};

          if (userData_after.messageID == userData.messageID) {
            _finishing_game(send, userID, threadID, Currencies, Users, true);
          }
        }
      } catch(e) {
        console.error(e);
      }
    });
  } else {
    _finishing_game(send, userID, threadID, Currencies, Users, false);
  }

  return;
}